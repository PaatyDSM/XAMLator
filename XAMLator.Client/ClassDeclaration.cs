using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace XAMLator.Client
{
	/// <summary>
	/// Represents a Xamarin Forms View class including the XAML view,
	/// the code-behind, the autogenerated code and other partial declarations
	/// of the class.
	/// When the class is updated with the current status of the class when
	/// the IDE notifies changes on any of the documents that composes this class.
	/// This tool was used to easilly generate the Roslyn code from sources
	/// https://roslynquoter.azurewebsites.net/
	/// </summary>
	public class ClassDeclaration
	{
		protected List<SyntaxTree> sources;
		protected List<MemberDeclarationSyntax> partials;
		ClassDeclarationSyntax classDeclarationSyntax;
		SemanticModel model;
		int counter = 0;
		List<string> usings;
		ISymbol symbol;
		string classFilePath;

		/// <summary>
		/// Initializes a new instance of the <see cref="T:XAMLator.Client.FormsViewClassDeclaration"/> class
		/// from a code behind document.
		/// </summary>
		/// <param name="classDeclarationSyntax">Class declaration syntax.</param>
		/// <param name="model">Model.</param>
		/// <param name="classFilePath">Code behind file path.</param>
		public ClassDeclaration(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel model,
								string classFilePath)
		{
			this.classFilePath = classFilePath;
			if (classDeclarationSyntax != null && model != null)
			{
				UpdateCode(classDeclarationSyntax, model);
			}
			ClassDeclarationsCache.Add(this);
		}

		/// <summary>
		/// Gets the name of the class.
		/// </summary>
		/// <value>The name of the class.</value>
		public string ClassName { get; protected set; }

		/// <summary>
		/// Gets the namespace.
		/// </summary>
		/// <value>The namespace.</value>
		public string Namespace { get; protected set; }

		/// <summary>
		/// Gets the full namespace including the class name.
		/// </summary>
		/// <value>The full namespace.</value>
		public string FullNamespace
		{
			get
			{
				if (String.IsNullOrWhiteSpace(Namespace))
				{
					return ClassName;
				}
				return $"{Namespace}.{ClassName}";
			}
		}

		/// <summary>
		/// Gets a value indicating whether this instance was created from a XAML
		/// document and still needs it's class initialization.
		/// </summary>
		/// <value><c>true</c> if needs class initialization; otherwise, <c>false</c>.</value>
		public bool NeedsClassInitialization { get; set; } = true;

		/// <summary>
		/// Gets the combined and updated code of the view.
		/// </summary>
		/// <value>The code.</value>
		public string Code { get; private set; }

		/// <summary>
		/// Gets the original code without types renamed.
		/// </summary>
		/// <value>The original code.</value>
		public string OriginalCode { get; private set; }

		/// <summary>
		/// Gets a value indicating whether the code of the view has changed
		/// and it needs to be rebuilt.
		/// </summary>
		/// <value><c>true</c> if needs rebuild; otherwise, <c>false</c>.</value>
		public bool NeedsRebuild { get; private set; }

		public virtual List<string> Files => new List<string> { classFilePath };

		string CurrentClassName => counter == 0 ? ClassName : $"{ClassName}{counter}";

		public string CurrentFullNamespace
		{
			get
			{
				if (String.IsNullOrWhiteSpace(Namespace))
				{
					return CurrentClassName;
				}
				return $"{Namespace}.{CurrentClassName}";
			}
		}

		/// <summary>
		/// Fills the class info.
		/// </summary>
		/// <param name="classDeclarationSyntax">Class declaration syntax.</param>
		/// <param name="model">Model.</param>
		internal void FillClassInfo(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel model)
		{
			this.classDeclarationSyntax = classDeclarationSyntax;
			this.model = model;
			FindSymbol();
			FillName();
			FillNamespace();
			FillSources();
			NeedsClassInitialization = false;
		}

		/// <summary>
		/// Updates the code behind of the class declaration.
		/// </summary>
		/// <param name="classDeclarationSyntax">Class declaration syntax.</param>
		internal protected virtual void UpdateCode(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel model)
		{
			FillClassInfo(classDeclarationSyntax, model);
			FillUsings();
			FillPartials();
			FillCode();
		}

		/// <summary>
		/// Finds the symbol representing the class.
		/// </summary>
		void FindSymbol()
		{
			symbol = model.GetDeclaredSymbol(classDeclarationSyntax);
		}

		/// <summary>
		/// Fills the name of the class.
		/// </summary>
		protected void FillName()
		{
			ClassName = classDeclarationSyntax.Identifier.Text;
		}

		/// <summary>
		/// Get the namespace of the class.
		/// </summary>
		protected void FillNamespace()
		{
			Namespace = classDeclarationSyntax.Ancestors()
				   .OfType<NamespaceDeclarationSyntax>()
				   .Select(n => n.Name.GetText().ToString().Trim())
						  .FirstOrDefault() ?? "";
		}

		/// <summary>
		/// Fills all the sources where this class is defined which can be one
		/// for a regular class or many for partial ones.
		/// </summary>
		protected virtual void FillSources()
		{
			sources = symbol.Locations.Select(l => l.SourceTree).ToList();
		}

		/// <summary>
		/// Fills code in partial classes excep the autogenerated one.
		/// </summary>
		protected void FillPartials()
		{
			partials = symbol.Locations
							 .Where(FileIsPartial)
							 .SelectMany(l => FindClass(l.SourceTree, classDeclarationSyntax.Identifier.Text).Members)
							 .ToList();
		}

		/// <summary>
		/// Fills all the usings requiered for this class.
		/// </summary>
		protected void FillUsings()
		{
			usings = sources.SelectMany(s => s.GetRoot()
										.DescendantNodes()
										.OfType<UsingDirectiveSyntax>()
										.Select(u => u.GetText().ToString()))
							.Distinct()
							.ToList();
		}

		/// <summary>
		/// Fills the code of the class combining all partials and removing comments.
		/// </summary>
		protected void FillCode()
		{
			var modifiersExceptPartial = TokenList(
				classDeclarationSyntax.Modifiers.Where(m => !m.IsKind(SyntaxKind.PartialKeyword)));
			var newIdentifier = Identifier(ClassName);

			var fullClass = classDeclarationSyntax
				.WithModifiers(modifiersExceptPartial)
				.AddMembers(partials.ToArray())
				.NormalizeWhitespace();

			var lines = fullClass.GetText().Lines.Select(l => l.ToString());
			var code = $"{String.Join("", usings)}\nnamespace {Namespace}\n{{\n {String.Join("\n", lines)} \n}}";
			if (code != OriginalCode)
			{
				counter++;
				OriginalCode = code;
				Code = ReplaceTypeName(code, ClassName, counter);
				NeedsRebuild = true;
			}
		}

		/// <summary>
		/// Replaces the name of the existing types in the code with the new type name.
		/// </summary>
		/// <returns>The type name.</returns>
		/// <param name="code">Code.</param>
		/// <param name="typeName">Type name.</param>
		/// <param name="counter">Counter.</param>
		string ReplaceTypeName(string code, string typeName, int counter)
		{
			// Make sure we only replace the class declaration and the constructors
			return Regex.Replace(code, $"(\\W+)({typeName})(\\W+)",
				$"$1{ClassName}{counter}$3", RegexOptions.Multiline);
		}

		/// <summary>
		/// Rewrites the autogenerated code constructor replace the LoadFromXaml
		/// call that reads the XAML fro the assembly resources for a call to
		/// <see cref="XAMLator.Server.VM.LoadXaml"/> that loads the XAML from
		/// the <see cref="EvalRequestMessage"/>
		/// </summary>
		/// <returns>The autogenerated code constructor.</returns>
		/// <param name="classDeclaration">Class declaration.</param>
		ClassDeclarationSyntax RewriteAutogeneratedCodeConstructor(ClassDeclarationSyntax classDeclaration)
		{
			var loadFromXaml = classDeclaration.DescendantNodes()
											   .OfType<ExpressionStatementSyntax>()
											   .Single(e => e.Expression.ToString().Contains("LoadFromXaml"));

			var newLoadXaml = ExpressionStatement(
				InvocationExpression(
					IdentifierName("XAMLator.Server.VM.LoadXaml"))
				.WithArgumentList(
					ArgumentList(
						SingletonSeparatedList(
						Argument(ThisExpression())))));

			return classDeclaration.ReplaceNode(loadFromXaml, newLoadXaml);
		}

		bool FileIsPartial(Location location)
		{
			return !Files.Contains(location.SourceTree.FilePath);
		}

		/// <summary>
		/// Finds a class for the given name in a syntax tree.
		/// </summary>
		/// <returns>The class.</returns>
		/// <param name="syntaxTree">Syntax tree.</param>
		/// <param name="className">Class name.</param>
		public static ClassDeclarationSyntax FindClass(SyntaxTree syntaxTree, string className)
		{
			return syntaxTree.GetRoot()
							 .DescendantNodes()
							 .OfType<ClassDeclarationSyntax>()
							 .Single(c => c.Identifier.Text == className);
		}
	}
}
