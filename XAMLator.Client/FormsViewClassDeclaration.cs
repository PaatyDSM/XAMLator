using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Xamarin.Forms.Build.Tasks;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace XAMLator.Client
{
	/// <summary>
	/// Represents a Xamarin Forms View class including the XAML view,
	/// the code-behind, the autogenerated code and other partial declarations
	/// of the class.
	/// When the class is updated with the current status of the class when
	/// the IDE notifies changes on any of the documents that composes this class.
	/// This tool was used to easilly generate the Roslyn code from sources
	/// https://roslynquoter.azurewebsites.net/
	/// </summary>
	public class FormsViewClassDeclaration : ClassDeclaration
	{
		static ConstructorInfo xamlGeneratorConstructor;
		static MethodInfo executeMethod;
		string autoGenCodeBehindCode;
		string xamlFilePath;
		string autoGenCodeBehindFilePath;

		static FormsViewClassDeclaration()
		{
			var assembly = Assembly.GetAssembly(typeof(XamlGTask));
			var type = assembly.GetType("Xamarin.Forms.Build.Tasks.XamlGenerator");
			xamlGeneratorConstructor = type.GetConstructors().Single(c => c.GetParameters().Length == 7);
			executeMethod = type.GetMethod("Execute");
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="T:XAMLator.Client.FormsViewClassDeclaration"/> class
		/// from a code behind document.
		/// </summary>
		/// <param name="classDeclarationSyntax">Class declaration syntax.</param>
		/// <param name="model">Model.</param>
		/// <param name="codeBehindFilePath">Code behind file path.</param>
		/// <param name="xaml">Xaml.</param>
		public FormsViewClassDeclaration(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel model,
										 string codeBehindFilePath, XAMLDocument xaml) : base(classDeclarationSyntax, model, codeBehindFilePath)
		{
			if (xaml != null)
			{
				xamlFilePath = xaml.FilePath;
				if (classDeclarationSyntax == null && model == null)
				{
					Namespace = xaml.Type.Substring(0, xaml.Type.LastIndexOf('.'));
					ClassName = xaml.Type.Split('.').Last();
				}
			}
			StyleSheets = new Dictionary<string, string>();
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="T:XAMLator.Client.FormsViewClassDeclaration"/> class
		/// from a XAML document.
		/// </summary>
		/// <param name="codeBehindFilePath">Code behind file path.</param>
		/// <param name="xaml">XAML.</param>
		public FormsViewClassDeclaration(string codeBehindFilePath, XAMLDocument xaml) : this(null, null, codeBehindFilePath, xaml)
		{
		}

		/// <summary>
		/// Gets the XAML of the view
		/// </summary>
		/// <value>The xaml.</value>
		public string Xaml { get; private set; }

		/// <summary>
		/// Gets the xaml resource identifier.
		/// </summary>
		/// <value>The xaml resource identifier.</value>
		// FIXME: This must be retrieved using the XamlResourceIdAttribute in the autogenerated
		// code behind
		public string XamlResourceId => xamlFilePath != null ? Path.GetFileName(xamlFilePath) : null;

		public Dictionary<string, string> StyleSheets { get; set; }

		/// <summary>
		/// Updates the XAML of the class declaration.
		/// </summary>
		/// <param name="xaml">Xaml.</param>
		internal async Task UpdateXaml(XAMLDocument xaml)
		{
			if (Xaml == xaml.XAML)
			{
				return;
			}
			Xaml = xaml.XAML;
			LoadStyleSheets(xaml);
			await UpdateAutoGeneratedCodeBehind();
			autoGenCodeBehindCode = null;
			FillAutoGenCodeBehind();
		}

		void LoadStyleSheets(XAMLDocument xaml)
		{
			foreach (var styleSheetPath in xaml.StyleSheets)
			{
				try
				{
					StyleSheets[styleSheetPath] = File.ReadAllText(ResolveStyleSheetPath(xaml, styleSheetPath));
				}
				catch (Exception ex)
				{
					Log.Exception(ex);
				}
			}
		}

		string ResolveStyleSheetPath(XAMLDocument xaml, string styleSheetPath)
		{
			if (styleSheetPath.StartsWith(Constants.ROOT_REPLACEMENT))
			{
				styleSheetPath = styleSheetPath.Replace(Constants.ROOT_REPLACEMENT + "/", "");
				var currentDir = Path.GetDirectoryName(xaml.FilePath);
				do
				{
					var filePath = Path.Combine(currentDir, styleSheetPath);
					if (File.Exists(filePath))
					{
						return filePath;
					}
					currentDir = Path.GetFullPath(Path.Combine(currentDir, ".."));
				} while (Directory.GetFiles(currentDir).Any(f => f.EndsWith(".sln"))
						 || currentDir == Directory.GetDirectoryRoot(currentDir));
				return null;
			}
			return Path.Combine(Path.GetDirectoryName(xaml.FilePath), styleSheetPath);
		}

		protected internal override void UpdateCode(ClassDeclarationSyntax classDeclarationSyntax, SemanticModel model)
		{
			FillClassInfo(classDeclarationSyntax, model);
			FillUsings();
			FillPartials();
			FillAutoGenCodeBehind();
			FillCode();
		}

		/// <summary>
		/// Fills all the sources where this class is defined which can be one
		/// for a regular class or many for partial ones.
		/// </summary>
		protected override void FillSources()
		{
			base.FillSources();
			autoGenCodeBehindFilePath = sources
				.Select(s => s.FilePath)
				.SingleOrDefault(s => s.EndsWith("g.cs"));
		}

		/// <summary>
		/// Fills the partial class in the auto generated code.
		/// </summary>
		void FillAutoGenCodeBehind()
		{
			if (!File.Exists(autoGenCodeBehindFilePath))
			{
				return;
			}
			if (String.IsNullOrEmpty(autoGenCodeBehindCode))
			{
				autoGenCodeBehindCode = File.ReadAllText(autoGenCodeBehindFilePath);
			}
			var syntaxTree = CSharpSyntaxTree.ParseText(autoGenCodeBehindCode);
			var newClass = RewriteAutogeneratedCodeConstructor(FindClass(syntaxTree, ClassName));
			var members = newClass.Members;
			partials.AddRange(members);
		}

		/// <summary>
		/// Updates the auto generated code behind when there is a change
		/// in the XAML as it might update local variable or events.
		/// </summary>
		async Task UpdateAutoGeneratedCodeBehind()
		{
			// FIXME: I couldn't manage to get this working with MonoDevelop
			// return XAMLatorMonitor.Instance.IDE.RunTarget("XamlG");

			if (String.IsNullOrEmpty(autoGenCodeBehindFilePath))
			{
				return;
			}
			try
			{
				object[] parameters = {xamlFilePath, "C#", FullNamespace + ".xaml",
					xamlFilePath, null, autoGenCodeBehindFilePath, null};
				var generator = xamlGeneratorConstructor.Invoke(parameters);
				executeMethod.Invoke(generator, null);
			}
			catch (Exception ex)
			{
				Log.Exception(ex);
			}
		}

		/// <summary>
		/// Rewrites the autogenerated code constructor replace the LoadFromXaml
		/// call that reads the XAML fro the assembly resources for a call to
		/// <see cref="XAMLator.Server.VM.LoadXaml"/> that loads the XAML from
		/// the <see cref="EvalRequestMessage"/>
		/// </summary>
		/// <returns>The autogenerated code constructor.</returns>
		/// <param name="classDeclaration">Class declaration.</param>
		ClassDeclarationSyntax RewriteAutogeneratedCodeConstructor(ClassDeclarationSyntax classDeclaration)
		{
			var loadFromXaml = classDeclaration.DescendantNodes()
											   .OfType<ExpressionStatementSyntax>()
											   .Single(e => e.Expression.ToString().Contains("LoadFromXaml"));

			var newLoadXaml = ExpressionStatement(
				InvocationExpression(
					IdentifierName("XAMLator.Server.VM.LoadXaml"))
				.WithArgumentList(
					ArgumentList(
						SingletonSeparatedList(
						Argument(ThisExpression())))));

			return classDeclaration.ReplaceNode(loadFromXaml, newLoadXaml);
		}

		internal static ClassDeclarationSyntax FindFormsViewClass(SyntaxTree syntaxTree, SemanticModel model)
		{
			return syntaxTree.GetRoot()
							 .DescendantNodes()
							 .OfType<ClassDeclarationSyntax>()
							 .First(c => IsViewOrPage(model.GetDeclaredSymbol(c)));
		}

		static bool IsViewOrPage(INamedTypeSymbol type)
		{
			do
			{
				var name = type.ToString();
				if (name == "Xamarin.Forms.Page" || name == "Xamarin.Forms.View" ||
					name == "Xamarin.Forms.ContentPage" || name == "Xamarin.Forms.ContentView")
				{
					return true;
				}
				type = type.BaseType;
			} while (type != null);
			return false;
		}
	}
}
